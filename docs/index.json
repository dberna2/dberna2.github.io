[{"categories":null,"contents":"Throughout my experience in software development, I‚Äôve learned that one of the main things to keep in mind is how the code we write will be tested. And not just that ‚Äî it‚Äôs also crucial to ensure that the tests actually work as they should, rather than just creating tests to meet a code coverage percentage and avoid issues with Sonar rules üòÖ.\nAt some point, we‚Äôve all written our own tests, and over time we‚Äôve found strategies that help us develop them more effectively. However, I‚Äôve also seen that when deadlines start to tighten in a project, two main things often happen:\nTesting is sacrificed (a decision that comes back to bite later) Developers are added to the project indiscriminately (a big mistake, especially when time is short) Even if it might not seem like it, tests are an excellent way to document our code. But to do this properly, we need time to write them and a team with at least a basic understanding of the project. Otherwise, we‚Äôll end up creating tests that only aim to meet a code coverage percentage. (In my opinion) üòÖ\nAs I mentioned earlier, a good way to document our code is through tests. And while there are other alternatives for documenting our APIs‚Äîsuch as Swagger or AsyncAPI in this case, I‚Äôll rely on the Spring REST Docs project. It generates a document that describes the full functionality of our API in a very elegant and intuitive way.\nPrerequisites Maven 3.6.X: https://maven.apache.org/download.cgi Java 11: https://www.oracle.com/java/technologies/downloads Intellij: https://www.jetbrains.com/idea/download User service To create our Spring Boot project, we go to https://start.spring.io/ and select the following configuration:\nWe add the Asciidoctor plugin First, we need to configure the Asciidoctor plugin, which will be responsible for collecting all the documents generated by our tests (snippets). The main properties to configure are: sourceDirectory, snippets, and backend.\nsourceDirectory: The path where our base template will be located, which will be used to generate the API documentation.\nsnippets: The location where the snippets specified in each of our tests will be generated.\nbackend: The type of document that will be generated for our API documentation. Possible values are: spring-html, html and pdf.\nTip: I replaced the spring-restdocs-asciidoctor dependency with spring-asciidoctor-backends in order to generate a document using a style proposed by the Spring team. You can check out the repository here.\nUserController For our service, we‚Äôll create a few endpoints where we can perform CRUD operations on a user and their possible accounts. To keep the service development concise, I used H2 as an in-memory database and Spring JPA to easily handle all database operations, allowing us to focus on what really matters: the tests. But if you‚Äôd like to take a look at the code, you can check it out here.\nUserControllerTest As I mentioned at the beginning of this post, ‚ÄúTests are an excellent way to document our code,‚Äù so in this case, we‚Äôll use MockMvc to make example requests to our API. We‚Äôll also use the ObjectMother pattern to represent our input and output data, which will serve as the contract our API must follow.\nRetrieve user by ID In this test, we retrieve a user‚Äôs basic information using their identifier and validate, using jsonPath, that the expected fields are present in the service‚Äôs response. So far, everything seems normal‚Äîbut if we take a closer look at the pathParameters and responseFields methods, we‚Äôll see that these are responsible for validating, through Spring Rest Docs, that the fields returned by the service are exactly the ones it‚Äôs supposed to return.\nNote: The value user-by-id will be the name used to generate our snippets, so try to choose a name that clearly describes the purpose of what it does.\nNote: The buildField method is a utility I used to avoid repeating the same configuration for the FieldDescriptor objects, which are used by Spring Rest Docs. If you‚Äôd like to see what this method does, you can check it out here.\nGenerated Snippets Once we complete the previous configuration and run our tests, we‚Äôll find all the generated snippets in the /target/generated-snippets directory, using the identifiers we specified.\n","permalink":"https://dberna2.github.io/blog/spring-rest-docs/","tags":["life","school","family","community"],"title":"‚ÄúDocument APIs using Spring Rest Docs‚Äù"},{"categories":null,"contents":"Wowwwww.\nI am just awed by the support and turnout from this community. You all just totally blew me away.\nThanks for everyone who voted, read, shared, attened, and asked. While the current board still needs to approve my election next month for my term beginning July I\u0026rsquo;m not going to lose any momentum. I already have a list of things to research and understand better, and I look forward to start building relationships with the team.\n","permalink":"https://dberna2.github.io/blog/example2/","tags":["life","school","family","community"],"title":"Eddie Webbinaro Elected School Board Member"},{"categories":null,"contents":"fgfgfg\n","permalink":"https://dberna2.github.io/blog/my-first/","tags":["life","school","family","community"],"title":"Eddie Webbinaro Elected School Board Member"},{"categories":null,"contents":"ReviewDog + GitHub Actions: enforce team agreements without breaking your flow Code style agreements are essential for long-term maintainability. But in most teams, enforcing them is tricky: warnings get ignored, and blocking the CI for every style rule can feel excessive. That‚Äôs where ReviewDog shines.\nThis setup uses ReviewDog in combination with CheckStyle and GitHub Actions to surface violations directly in pull requests ‚Äî without interrupting builds. Developers get inline comments tied to their changes, keeping the review focused on business logic while still catching style issues early.\nThe GitHub Action acts as a bridge between your linter and ReviewDog, translating CLI output into annotated feedback on your PR. This creates a lightweight but highly visible layer of enforcement for your team‚Äôs coding standards.\nEven better: it scales with your rules. Whether you‚Äôre just starting with a few basic checks or managing a full custom CheckStyle config, ReviewDog integrates seamlessly ‚Äî and enforces agreements without friction.\n‚öôÔ∏è Example: GitHub Action for CheckStyle + ReviewDog Here‚Äôs a minimal example of how to integrate CheckStyle and ReviewDog in a GitHub Action:\nname: reviewdog-checkstyle on: [pull_request] jobs: checkstyle: name: CheckStyle Lint runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Set up Java uses: actions/setup-java@v3 with: distribution: \u0026#39;temurin\u0026#39; java-version: \u0026#39;17\u0026#39; - name: Run CheckStyle run: | ./gradlew checkstyleMain -PcheckstyleOutputFile=checkstyle-result.xml - name: Run ReviewDog uses: reviewdog/action-checkstyle@v1 with: github_token: ${{ secrets.GITHUB_TOKEN }} reporter: github-pr-review checkstyle_reporter_output: checkstyle-result.xml Make sure your CheckStyle task is configured to output in XML format, and that checkstyle-result.xml points to the correct path.\nResult You can see the example here\n","permalink":"https://dberna2.github.io/projects/creations/check-style/","tags":["Java","Code Style","ReviewDog","GitHub Actions","CheckStyle"],"title":"Checkstyle for Java using GitHub Action and Reviewdog"},{"categories":null,"contents":"\n","permalink":"https://dberna2.github.io/contact/","tags":null,"title":"Eddie Webbinaro"}]